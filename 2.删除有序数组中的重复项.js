/**
 * 删除有序数组中的重复项
 * 给你一个 升序排列 的数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次
 * 返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。然后返回 nums 中唯一元素的个数。
 * 考虑 nums 的唯一元素的数量为 k ，你需要做以下事情确保你的题解可以被通过：
 * 更改数组 nums ，使 nums 的前 k 个元素包含唯一元素，
 * 并按照它们最初在 nums 中出现的顺序排列。nums 的其余元素与 nums 的大小不重要。
 * 返回 k 。
 * **/
/**
 * @param {number[]} nums
 * @return {number}
 */
var removeDuplicates = function (nums) {
  // 好理解，但是复杂度为O(n^2)
  // for(let i =0;i<nums.length;i++){
  // if(nums.indexOf(nums[i])!==nums.lastIndexOf(nums[i])){
  //     nums.splice(i,1)
  //     i--
  // }
  // 双指针优化
  // }
  // 双指针优化
  if (!nums.length) {
    // 长度为0不可能存在重复性直接return 0
    return 0
  }
  // 设置慢指针
  let slow = 0

  for (let fast = 1; fast < nums.length; fast++) {
    // 快指针为fast
    if (nums[fast] !== nums[slow]) {
      // 如果如果快指针的值不等于慢指针的值那么那么
      // 慢指针向下走一位
      slow++
      // 把下一位的值替换为当前快指针指向的值
      nums[slow] = nums[fast]
    }
  }
  // 最后就会返回不重复项的长度
  return slow + 1
}
// 双指针讲解，首先因为数组是有序存在的，那么不存在重复的情况下nums[i]<nums[i+1]的，
// 并且相同的肯定是相邻的，因为是有序存在的。
// 那么慢指针和快指针同时指向了0，快指针一直往前走，
// 如果碰到与满指针指向的值不一样的话那么就把满指针的下一给替换为当前的值
// 为什么是下一位，因为当前值还是需要存在的，有可能是唯一性的,下一位与当前位置如果是不重复的那么
// 只相当于慢指针走了一步，【1，2】，nums[1]=nums[1],如果是重复的，相当与重复的值替换为了下一位有序的邻值给了它
// 最后返回慢指针+1，因为慢指针指向的是不重复的数组的长度

// 例如，1，1，2，2，2，3，3，4
// 首先满指针和快指针同时指向了1，快指针接着走，慢指针不动
// 接下来快指针指向了第一个2，那么与满指针的值是不一样的，那么满指针自加加
// 就到了第二个1的位置，把第二个1改为了2，接下来走到第二个而与慢指针一样，然后就是接着向上面一样
// 快指针继续走，满指针不懂

// 例子2：1，2，3，4，5，6，6
// 要是这样的起始和上面差不多，只要是有序的就可以判断，因为无序的话[9,8,6,2,6,1,6,7,4,3,1,8],向这样的话
// 满指针和快指针就会发生并行走的操作，例如，首先快慢指针同时指向9，下一位不一样，然后进行替换，这样一直
// 并行到6，6是有重复的，但是此刻快指针指向了2，那么与6不一样会替换，此刻满指针就又指向了2，接下来再到六还是不一样

// 接下来将例子2 ：这个的话也是并行，因为前面一直不存在重复项，但是到最后的时候，就是最后一个6的时候不做操作
// 因为相同，然后快指针接着走，走完条件不成立了，然后终止循环，返回满指针的指向的索引
